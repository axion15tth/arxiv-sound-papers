# システム設計書：arXiv Sound Papers Viewer

## 1. システムアーキテクチャ

### 1.1 全体構成図

```
┌─────────────────────────────────────────────────────────────┐
│                      ユーザー（ブラウザ）                      │
└───────────────────┬─────────────────────────────────────────┘
                    │
                    │ HTTPS
                    │
    ┌───────────────┼───────────────────────────────────┐
    │               │                                   │
    v               v                                   v
┌─────────┐  ┌──────────────┐              ┌────────────────┐
│ GitHub  │  │   Firebase   │              │  External APIs │
│ Pages   │  │              │              │                │
│         │  │ ・Authentication            │ ・arXiv API    │
│ ・React │  │ ・Firestore  │              │ ・Google       │
│  App    │  │   Database   │              │  Translate API │
│ ・JSON  │  └──────────────┘              └────────────────┘
│  Data   │                                         ↑
└─────────┘                                         │
     ↑                                              │
     │                                              │
     └────────────┐                                 │
                  │                                 │
            ┌─────┴─────────┐                       │
            │ GitHub Actions│                       │
            │  or Local     │───────────────────────┘
            │               │
            │ ・データ収集   │
            │ ・翻訳処理     │
            └───────────────┘
```

### 1.2 技術スタック

| レイヤー | 技術 | 用途 |
|---------|------|------|
| フロントエンド | React 18+ | UIフレームワーク |
| スタイリング | Tailwind CSS | CSSフレームワーク |
| 状態管理 | React Context API / useReducer | グローバル状態管理 |
| ルーティング | React Router v6 | SPA ルーティング |
| 認証 | Firebase Authentication | ユーザー認証 |
| データベース | Firebase Firestore | ブックマーク・タグ保存 |
| ホスティング | GitHub Pages | 静的サイトホスティング |
| データ収集 | Python 3.10+ | スクリプト実行 |
| 外部API | arXiv API, Google Translate API | データ取得・翻訳 |
| CI/CD | GitHub Actions | 自動デプロイ（オプション） |

---

## 2. データベース設計（Firebase Firestore）

### 2.1 コレクション構造

```
users/
  {userId}/
    profile/
      - email: string
      - displayName: string
      - createdAt: timestamp
      - lastLogin: timestamp

    bookmarks/
      {paperId}/
        - arxivId: string
        - title: string
        - titleJa: string
        - authors: array<string>
        - publishedDate: string
        - categories: array<string>
        - url: string
        - bookmarkedAt: timestamp
        - tags: array<string>  // タグIDの配列

    tags/
      {tagId}/
        - name: string
        - color: string (hex color code)
        - createdAt: timestamp
        - paperCount: number  // このタグを持つ論文数
```

### 2.2 データモデル詳細

#### 2.2.1 Paper（論文データ - JSONファイル）

```json
{
  "papers": [
    {
      "id": "2401.12345",
      "arxivId": "2401.12345",
      "title": "Deep Learning for Audio Signal Processing",
      "titleJa": "音響信号処理のための深層学習",
      "authors": ["John Doe", "Jane Smith"],
      "publishedDate": "2024-01-15",
      "categories": ["cs.SD", "eess.AS"],
      "abstract": "This paper presents...",
      "url": "https://arxiv.org/abs/2401.12345",
      "pdfUrl": "https://arxiv.org/pdf/2401.12345.pdf"
    }
  ],
  "lastUpdated": "2024-01-20T10:00:00Z"
}
```

#### 2.2.2 Bookmark（Firestore）

```typescript
interface Bookmark {
  arxivId: string;          // arXiv ID（例: "2401.12345"）
  title: string;            // 論文タイトル（英語）
  titleJa: string;          // 論文タイトル（日本語）
  authors: string[];        // 著者リスト
  publishedDate: string;    // 公開日（ISO 8601形式）
  categories: string[];     // arXivカテゴリ
  url: string;              // arXiv URL
  bookmarkedAt: Timestamp;  // ブックマーク登録日時
  tags: string[];           // タグIDの配列
}
```

#### 2.2.3 Tag（Firestore）

```typescript
interface Tag {
  id: string;               // Firestore自動生成ID
  name: string;             // タグ名（例: "音声認識"）
  color: string;            // 色コード（例: "#3B82F6"）
  createdAt: Timestamp;     // 作成日時
  paperCount: number;       // このタグを持つ論文数
}
```

#### 2.2.4 UserProfile（Firestore）

```typescript
interface UserProfile {
  email: string;
  displayName: string;
  photoURL?: string;
  createdAt: Timestamp;
  lastLogin: Timestamp;
}
```

### 2.3 Firestoreセキュリティルール

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ユーザーは自分のデータのみ読み書き可能
    match /users/{userId}/{document=**} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // 他のユーザーのデータは読み書き不可
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
```

---

## 3. フロントエンド設計

### 3.1 ディレクトリ構造

```
src/
├── components/           # UIコンポーネント
│   ├── common/          # 共通コンポーネント
│   │   ├── Header.jsx
│   │   ├── Footer.jsx
│   │   ├── Loader.jsx
│   │   └── ErrorBoundary.jsx
│   ├── paper/           # 論文関連コンポーネント
│   │   ├── PaperList.jsx
│   │   ├── PaperCard.jsx
│   │   ├── PaperDetail.jsx
│   │   └── BookmarkButton.jsx
│   ├── filter/          # フィルタリングコンポーネント
│   │   ├── SearchBar.jsx
│   │   ├── DateFilter.jsx
│   │   ├── CategoryFilter.jsx
│   │   └── TagFilter.jsx
│   ├── bookmark/        # ブックマーク関連
│   │   ├── BookmarkList.jsx
│   │   └── BookmarkManager.jsx
│   ├── tag/             # タグ関連コンポーネント
│   │   ├── TagList.jsx
│   │   ├── TagEditor.jsx
│   │   ├── TagSelector.jsx
│   │   └── TagBadge.jsx
│   └── auth/            # 認証関連
│       ├── LoginButton.jsx
│       ├── LogoutButton.jsx
│       └── UserProfile.jsx
├── pages/               # ページコンポーネント
│   ├── HomePage.jsx
│   ├── BookmarksPage.jsx
│   ├── TagsPage.jsx
│   └── NotFoundPage.jsx
├── hooks/               # カスタムフック
│   ├── useAuth.js       # 認証状態管理
│   ├── usePapers.js     # 論文データ取得
│   ├── useBookmarks.js  # ブックマーク管理
│   ├── useTags.js       # タグ管理
│   └── useFilter.js     # フィルタリング状態
├── services/            # 外部サービス連携
│   ├── firebase.js      # Firebase初期化
│   ├── auth.js          # 認証サービス
│   ├── bookmarkService.js
│   └── tagService.js
├── context/             # React Context
│   ├── AuthContext.jsx
│   ├── PaperContext.jsx
│   └── FilterContext.jsx
├── utils/               # ユーティリティ関数
│   ├── dateUtils.js
│   ├── filterUtils.js
│   └── constants.js
├── styles/              # スタイル
│   └── index.css
├── App.jsx              # メインアプリケーション
└── index.js             # エントリーポイント
```

### 3.2 主要コンポーネント設計

#### 3.2.1 App.jsx

```jsx
import React from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';
import { PaperProvider } from './context/PaperContext';
import Header from './components/common/Header';
import HomePage from './pages/HomePage';
import BookmarksPage from './pages/BookmarksPage';
import TagsPage from './pages/TagsPage';

function App() {
  return (
    <AuthProvider>
      <PaperProvider>
        <BrowserRouter>
          <Header />
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route path="/bookmarks" element={<BookmarksPage />} />
            <Route path="/tags" element={<TagsPage />} />
          </Routes>
        </BrowserRouter>
      </PaperProvider>
    </AuthProvider>
  );
}
```

#### 3.2.2 PaperCard.jsx

```jsx
import React from 'react';
import BookmarkButton from './BookmarkButton';
import TagBadge from '../tag/TagBadge';

function PaperCard({ paper, isBookmarked, tags }) {
  return (
    <div className="paper-card">
      <div className="paper-header">
        <h3>{paper.titleJa}</h3>
        <p className="original-title">{paper.title}</p>
      </div>

      <div className="paper-meta">
        <span className="authors">{paper.authors.join(', ')}</span>
        <span className="date">{paper.publishedDate}</span>
      </div>

      <div className="paper-categories">
        {paper.categories.map(cat => (
          <span key={cat} className="category-badge">{cat}</span>
        ))}
      </div>

      {tags && tags.length > 0 && (
        <div className="paper-tags">
          {tags.map(tag => (
            <TagBadge key={tag.id} tag={tag} />
          ))}
        </div>
      )}

      <div className="paper-actions">
        <a href={paper.url} target="_blank" rel="noopener noreferrer">
          arXivで見る
        </a>
        <BookmarkButton paper={paper} isBookmarked={isBookmarked} />
      </div>
    </div>
  );
}
```

#### 3.2.3 TagEditor.jsx

```jsx
import React, { useState } from 'react';
import { createTag, deleteTag, updateTag } from '../../services/tagService';

function TagEditor({ tags, onTagsChange }) {
  const [newTagName, setNewTagName] = useState('');
  const [newTagColor, setNewTagColor] = useState('#3B82F6');

  const handleCreateTag = async () => {
    if (!newTagName.trim()) return;

    const tag = await createTag({
      name: newTagName,
      color: newTagColor
    });

    onTagsChange([...tags, tag]);
    setNewTagName('');
  };

  const handleDeleteTag = async (tagId) => {
    await deleteTag(tagId);
    onTagsChange(tags.filter(t => t.id !== tagId));
  };

  return (
    <div className="tag-editor">
      <div className="create-tag">
        <input
          type="text"
          value={newTagName}
          onChange={(e) => setNewTagName(e.target.value)}
          placeholder="新しいタグ名"
        />
        <input
          type="color"
          value={newTagColor}
          onChange={(e) => setNewTagColor(e.target.value)}
        />
        <button onClick={handleCreateTag}>作成</button>
      </div>

      <div className="tag-list">
        {tags.map(tag => (
          <div key={tag.id} className="tag-item">
            <TagBadge tag={tag} />
            <span>{tag.paperCount}件</span>
            <button onClick={() => handleDeleteTag(tag.id)}>削除</button>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 3.3 カスタムフック設計

#### 3.3.1 useBookmarks.js

```javascript
import { useState, useEffect } from 'react';
import { collection, query, onSnapshot } from 'firebase/firestore';
import { db } from '../services/firebase';
import { useAuth } from './useAuth';

export function useBookmarks() {
  const { user } = useAuth();
  const [bookmarks, setBookmarks] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!user) {
      setBookmarks([]);
      setLoading(false);
      return;
    }

    const q = query(
      collection(db, 'users', user.uid, 'bookmarks')
    );

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const bookmarkData = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      setBookmarks(bookmarkData);
      setLoading(false);
    });

    return () => unsubscribe();
  }, [user]);

  return { bookmarks, loading };
}
```

#### 3.3.2 useTags.js

```javascript
import { useState, useEffect } from 'react';
import { collection, query, onSnapshot, orderBy } from 'firebase/firestore';
import { db } from '../services/firebase';
import { useAuth } from './useAuth';

export function useTags() {
  const { user } = useAuth();
  const [tags, setTags] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!user) {
      setTags([]);
      setLoading(false);
      return;
    }

    const q = query(
      collection(db, 'users', user.uid, 'tags'),
      orderBy('name')
    );

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const tagData = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      setTags(tagData);
      setLoading(false);
    });

    return () => unsubscribe();
  }, [user]);

  return { tags, loading };
}
```

---

## 4. バックエンド設計（データ収集スクリプト）

### 4.1 ディレクトリ構造

```
scripts/
├── fetch_papers.py      # arXiv APIからデータ取得
├── translate.py         # Google Translate APIで翻訳
├── main.py              # メインスクリプト
├── config.py            # 設定ファイル
├── requirements.txt     # Python依存関係
└── .env.example         # 環境変数サンプル
```

### 4.2 fetch_papers.py

```python
import requests
import xml.etree.ElementTree as ET
from datetime import datetime, timedelta

class ArxivFetcher:
    BASE_URL = "http://export.arxiv.org/api/query"

    def __init__(self, categories, keywords, days_back=7):
        self.categories = categories  # ["cs.SD", "eess.AS", "cs.AI"]
        self.keywords = keywords      # ["audio", "speech", "sound", "music"]
        self.days_back = days_back

    def fetch_papers(self):
        """指定されたカテゴリとキーワードで論文を取得"""
        papers = []

        # カテゴリベースの検索
        for category in self.categories:
            papers.extend(self._fetch_by_category(category))

        # キーワードベースの検索
        for keyword in self.keywords:
            papers.extend(self._fetch_by_keyword(keyword))

        # 重複削除
        unique_papers = self._remove_duplicates(papers)

        return unique_papers

    def _fetch_by_category(self, category):
        """カテゴリで検索"""
        query = f"cat:{category}"
        return self._query_arxiv(query)

    def _fetch_by_keyword(self, keyword):
        """キーワードで検索（音響関連カテゴリに限定）"""
        query = f"(all:{keyword}) AND (cat:cs.SD OR cat:eess.AS)"
        return self._query_arxiv(query)

    def _query_arxiv(self, query):
        """arXiv APIにクエリを送信"""
        start_date = (datetime.now() - timedelta(days=self.days_back)).strftime("%Y%m%d")
        params = {
            "search_query": query,
            "start": 0,
            "max_results": 100,
            "sortBy": "submittedDate",
            "sortOrder": "descending"
        }

        response = requests.get(self.BASE_URL, params=params)
        papers = self._parse_response(response.text)

        # 日付フィルタリング
        filtered_papers = [
            p for p in papers
            if p['publishedDate'] >= start_date
        ]

        return filtered_papers

    def _parse_response(self, xml_text):
        """XMLレスポンスをパース"""
        root = ET.fromstring(xml_text)
        ns = {'atom': 'http://www.w3.org/2005/Atom'}

        papers = []
        for entry in root.findall('atom:entry', ns):
            paper = {
                'id': entry.find('atom:id', ns).text.split('/')[-1],
                'arxivId': entry.find('atom:id', ns).text.split('/')[-1],
                'title': entry.find('atom:title', ns).text.strip(),
                'authors': [
                    author.find('atom:name', ns).text
                    for author in entry.findall('atom:author', ns)
                ],
                'publishedDate': entry.find('atom:published', ns).text[:10],
                'categories': [
                    cat.get('term')
                    for cat in entry.findall('atom:category', ns)
                ],
                'abstract': entry.find('atom:summary', ns).text.strip(),
                'url': entry.find('atom:id', ns).text,
                'pdfUrl': entry.find('atom:id', ns).text.replace('/abs/', '/pdf/')
            }
            papers.append(paper)

        return papers

    def _remove_duplicates(self, papers):
        """重複する論文を削除"""
        seen = set()
        unique = []
        for paper in papers:
            if paper['arxivId'] not in seen:
                seen.add(paper['arxivId'])
                unique.append(paper)
        return unique
```

### 4.3 translate.py

```python
from google.cloud import translate_v2 as translate

class Translator:
    def __init__(self, api_key=None):
        if api_key:
            self.client = translate.Client(api_key=api_key)
        else:
            self.client = translate.Client()

    def translate_papers(self, papers):
        """論文タイトルを日本語に翻訳"""
        for paper in papers:
            try:
                result = self.client.translate(
                    paper['title'],
                    source_language='en',
                    target_language='ja'
                )
                paper['titleJa'] = result['translatedText']
            except Exception as e:
                print(f"翻訳エラー: {paper['id']} - {e}")
                paper['titleJa'] = paper['title']  # フォールバック

        return papers
```

### 4.4 main.py

```python
import json
from datetime import datetime
from fetch_papers import ArxivFetcher
from translate import Translator
from config import CATEGORIES, KEYWORDS, DAYS_BACK

def main():
    print("arXiv論文データ収集開始...")

    # 1. 論文データ取得
    fetcher = ArxivFetcher(
        categories=CATEGORIES,
        keywords=KEYWORDS,
        days_back=DAYS_BACK
    )
    papers = fetcher.fetch_papers()
    print(f"{len(papers)}件の論文を取得しました")

    # 2. 翻訳
    translator = Translator()
    papers = translator.translate_papers(papers)
    print("翻訳完了")

    # 3. JSON保存
    output = {
        "papers": papers,
        "lastUpdated": datetime.now().isoformat()
    }

    with open('../data/papers.json', 'w', encoding='utf-8') as f:
        json.dump(output, f, ensure_ascii=False, indent=2)

    print("データ保存完了: data/papers.json")

if __name__ == "__main__":
    main()
```

### 4.5 config.py

```python
import os
from dotenv import load_dotenv

load_dotenv()

# arXiv設定
CATEGORIES = ["cs.SD", "eess.AS", "cs.AI"]
KEYWORDS = ["audio", "speech", "sound", "music", "acoustic"]
DAYS_BACK = 7  # 過去何日分取得するか

# Google Translate API
GOOGLE_API_KEY = os.getenv("GOOGLE_TRANSLATE_API_KEY")
```

---

## 5. デプロイメント設計

### 5.1 GitHub Actionsワークフロー（オプション）

```yaml
# .github/workflows/update-papers.yml
name: Update Papers Data

on:
  schedule:
    - cron: '0 0 * * *'  # 毎日0時（UTC）に実行
  workflow_dispatch:      # 手動実行も可能

jobs:
  update-data:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          cd scripts
          pip install -r requirements.txt

      - name: Fetch and translate papers
        env:
          GOOGLE_TRANSLATE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
        run: |
          cd scripts
          python main.py

      - name: Commit and push
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add data/papers.json
          git commit -m "Update papers data" || exit 0
          git push
```

### 5.2 Firebase設定

```javascript
// src/services/firebase.js
import { initializeApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';

const firebaseConfig = {
  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,
  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,
  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.REACT_APP_FIREBASE_APP_ID
};

const app = initializeApp(firebaseConfig);
export const auth = getAuth(app);
export const db = getFirestore(app);
```

---

## 6. API設計

### 6.1 Firestore操作API

#### 6.1.1 ブックマーク操作

```javascript
// services/bookmarkService.js

// ブックマーク追加
export async function addBookmark(userId, paper) {
  const bookmarkRef = doc(db, 'users', userId, 'bookmarks', paper.id);
  await setDoc(bookmarkRef, {
    arxivId: paper.arxivId,
    title: paper.title,
    titleJa: paper.titleJa,
    authors: paper.authors,
    publishedDate: paper.publishedDate,
    categories: paper.categories,
    url: paper.url,
    bookmarkedAt: serverTimestamp(),
    tags: []
  });
}

// ブックマーク削除
export async function removeBookmark(userId, paperId) {
  const bookmarkRef = doc(db, 'users', userId, 'bookmarks', paperId);
  await deleteDoc(bookmarkRef);
}

// タグを論文に追加
export async function addTagToBookmark(userId, paperId, tagId) {
  const bookmarkRef = doc(db, 'users', userId, 'bookmarks', paperId);
  await updateDoc(bookmarkRef, {
    tags: arrayUnion(tagId)
  });

  // タグの論文カウントを更新
  await incrementTagPaperCount(userId, tagId, 1);
}

// タグを論文から削除
export async function removeTagFromBookmark(userId, paperId, tagId) {
  const bookmarkRef = doc(db, 'users', userId, 'bookmarks', paperId);
  await updateDoc(bookmarkRef, {
    tags: arrayRemove(tagId)
  });

  // タグの論文カウントを更新
  await incrementTagPaperCount(userId, tagId, -1);
}
```

#### 6.1.2 タグ操作

```javascript
// services/tagService.js

// タグ作成
export async function createTag(userId, tagData) {
  const tagRef = collection(db, 'users', userId, 'tags');
  const docRef = await addDoc(tagRef, {
    name: tagData.name,
    color: tagData.color || '#3B82F6',
    createdAt: serverTimestamp(),
    paperCount: 0
  });
  return { id: docRef.id, ...tagData };
}

// タグ削除
export async function deleteTag(userId, tagId) {
  // タグを削除
  const tagRef = doc(db, 'users', userId, 'tags', tagId);
  await deleteDoc(tagRef);

  // すべてのブックマークからこのタグを削除
  const bookmarksRef = collection(db, 'users', userId, 'bookmarks');
  const q = query(bookmarksRef, where('tags', 'array-contains', tagId));
  const snapshot = await getDocs(q);

  const batch = writeBatch(db);
  snapshot.docs.forEach(doc => {
    batch.update(doc.ref, {
      tags: arrayRemove(tagId)
    });
  });
  await batch.commit();
}

// タグ名更新
export async function updateTag(userId, tagId, updates) {
  const tagRef = doc(db, 'users', userId, 'tags', tagId);
  await updateDoc(tagRef, updates);
}

// タグの論文カウント更新
async function incrementTagPaperCount(userId, tagId, increment) {
  const tagRef = doc(db, 'users', userId, 'tags', tagId);
  await updateDoc(tagRef, {
    paperCount: increment(increment)
  });
}
```

---

## 7. パフォーマンス最適化

### 7.1 フロントエンド最適化
- React.memoで不要な再レンダリングを防止
- 仮想スクロール（react-window）で大量論文の表示を最適化
- 画像の遅延読み込み
- Code Splitting（React.lazy）でバンドルサイズ削減

### 7.2 データベース最適化
- Firestoreインデックス設定
- 複合クエリの最適化
- ページネーションの実装（必要に応じて）

### 7.3 キャッシュ戦略
- papers.jsonはService Workerでキャッシュ
- Firestoreのオフライン永続化有効化

---

## 8. セキュリティ設計

### 8.1 認証
- Firebase Authenticationによる安全な認証
- OAuth 2.0（Google認証）

### 8.2 APIキー管理
- 環境変数（.env）でAPIキーを管理
- GitHub Secretsで機密情報を保護
- .gitignoreに.envを追加

### 8.3 Firestoreセキュリティ
- ユーザーは自分のデータのみアクセス可能
- クライアント側での入力バリデーション
- Firestoreルールでサーバー側バリデーション

---

## 9. テスト計画

### 9.1 単体テスト
- Jest + React Testing Libraryでコンポーネントテスト
- カスタムフックのテスト

### 9.2 統合テスト
- Firebase Emulatorでバックエンド連携テスト

### 9.3 E2Eテスト（オプション）
- Playwrightでユーザーフロー全体をテスト

---

## 10. 運用・保守

### 10.1 モニタリング
- Firebase Analyticsでユーザー行動分析
- Firebase Crashlyticsでエラー監視（オプション）

### 10.2 バックアップ
- Firestoreの自動バックアップ設定
- papers.jsonのGit履歴管理

### 10.3 更新手順
1. スクリプト実行（手動またはGitHub Actions）
2. データ確認
3. GitHubにプッシュ
4. GitHub Pagesに自動デプロイ

---

## 11. 今後の技術的拡張

- Progressive Web App（PWA）化
- プッシュ通知（新着論文アラート）
- 論文推薦機能（機械学習）
- コメント・メモ機能（Firestoreに保存）
- 論文のPDFビューア統合
